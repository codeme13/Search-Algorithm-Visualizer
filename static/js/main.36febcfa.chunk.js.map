{"version":3,"sources":["grid-context.js","components/Navbar.jsx","components/Cell.jsx","components/Grid.jsx","components/AlgoInfo.jsx","utilities/initGrid.js","utilities/getCoordinates.js","utilities/removeCells.js","utilities/searchHelpers.js","utilities/PriorityQueue.js","utilities/mazeHandler.js","utilities/mazes/randomWeights.js","utilities/mazes/randomMaze.js","components/App.jsx","utilities/searchAlgorithms/DFS.js","utilities/searchAlgorithms/BFS.js","utilities/searchAlgorithms/Dijkstra.js","utilities/searchAlgorithms/AStar.js","utilities/searchAlgorithms/Greedy.js","utilities/movePoint.js","index.js"],"names":["myState","grid","startPoint","target","selectedCells","algorithm","mousePressed","selectedCellVal","visited","path","speed","lockBoard","lockClearPath","setAlgorithm","console","log","createMaze","resetBoard","toggleMousePressed","toggleCell","id","visualize","changeSpeed","GridContext","React","createContext","Navbar","props","handleClick","state","visualizeClicked","context","setState","handleAlgo","event","handleMaze","handleSpeed","newSpeed","bind","algorithmDisplay","visualizeColor","lock","this","className","href","onClick","style","backgroundColor","pointerEvents","type","data-toggle","aria-haspopup","aria-expanded","aria-labelledby","Component","contextType","Cell","cellState","handleMouseUp","handleDrag","componentDidMount","delayAnim","delay","undefined","startsWith","includes","toString","animationDelay","onMouseDown","e","onMouseUp","onMouseOver","Grid","getVisitedIndex","indexes","i","length","createTable","table","children","j","push","key","AlgoInfo","getAlgoProps","algo","weighted","shortestPath","getStats","algoStats","searchResults","algoProps","initGrid","dimensions","getGridDimensions","rows","columns","Array","fill","map","row","startPoints","getStartPoints","updateGrid","endPoints","getTargetPoints","Math","floor","window","innerWidth","innerHeight","startX","targetX","x","y","value","r","c","getCoordinates","split","el","parseInt","removeCells","weights","replace","searchHelpers","arraysMatch","arr1","arr2","inBounds","vertex","hasVertex","array","array2D","getNeighbours","rowCount","colCount","neighbours","getPath","end","pathArray","currentCell","unshift","manhattanDistance","position1","position2","abs","PriorityQueue","data","priority","index","min","Infinity","splice","mazeHandler","maze","newMaze","start","n","random","randomWeights","width","height","chooseOrientation","randomMazeUtil","orientation","horizontal","wx","wy","px","py","dx","dy","nx","ny","w","h","randomMaze","App","showPath","results","stack","cur","pop","neighbors","neighbour","tempCur","dfs","newGrid","gridWithPath","arr","slice","DFS","neighbor","bfs","BFS","distances","pq","thisCell","size","minCell","currentNode","neighborWeight","alternative","dijkstra","Dijkstra","gScore","fScore","open","potentialScore","AStar","cost","greedy","Greedy","willVisualize","setTimeout","pathShown","resetSearch","getStart","getTarget","cellValue","newCell","points","newCellValue","currentX","currentY","newX","newY","curVal","lastCell","cell","drag","previousProps","previousState","Provider","ReactDOM","render","document","querySelector"],"mappings":"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","file":"static/js/main.36febcfa.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nexport const myState = {\r\n  grid: [],\r\n  startPoint: null,\r\n  target: null,\r\n  selectedCells: [],\r\n  algorithm: null,\r\n  mousePressed: false,\r\n  selectedCellVal: false,\r\n  visited: [],\r\n  path: [],\r\n  speed: [0.01, 0.02],\r\n  lockBoard: false,\r\n  lockClearPath: false,\r\n  setAlgorithm: () => {\r\n    console.log(\"set algo\");\r\n  },\r\n  createMaze: () => {\r\n    console.log(\"create maze\");\r\n  },\r\n  resetBoard: () => {\r\n    console.log(\"reset\");\r\n  },\r\n  toggleMousePressed: () => {\r\n    console.log(\"mouse pressed?\");\r\n  },\r\n  toggleCell: id => {\r\n    console.log(id);\r\n  },\r\n  visualize: algorithm => {\r\n    console.log(\"algo\");\r\n  },\r\n  changeSpeed: speed => {\r\n    console.log(\"algo\");\r\n  }\r\n};\r\n\r\nexport const GridContext = React.createContext(myState);\r\n","import React from \"react\";\r\nimport \"./Navbar.scss\";\r\n\r\nimport { GridContext } from \"../grid-context\";\r\n\r\nclass Navbar extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { visualizeClicked: false };\r\n    this.handleSpeed = this.handleSpeed.bind(this);\r\n    this.handleAlgo = this.handleAlgo.bind(this);\r\n    this.handleMaze = this.handleMaze.bind(this);\r\n  }\r\n\r\n  // options for keeping board in tact but removing visited and path nodes ??\r\n  handleClick = algorithm => {\r\n    if (!this.state.visualizeClicked) {\r\n      let { visualize } = this.context;\r\n      visualize(algorithm);\r\n    } else {\r\n      let { resetBoard } = this.context;\r\n      const resetSearch = true;\r\n      resetBoard(resetSearch);\r\n    }\r\n    if (this.state.visualizeClicked && algorithm !== null)\r\n      this.setState({ visualizeClicked: false });\r\n    else if (!this.state.visualizeClicked && algorithm !== null)\r\n      this.setState({ visualizeClicked: true });\r\n  };\r\n\r\n  handleAlgo = event => {\r\n    let { setAlgorithm } = this.context;\r\n    setAlgorithm(event.target.id);\r\n  };\r\n\r\n  handleMaze = event => {\r\n    let { createMaze } = this.context;\r\n    createMaze(event.target.id);\r\n  };\r\n\r\n  handleSpeed = event => {\r\n    let { changeSpeed } = this.context;\r\n    const speed = event.target.id;\r\n    let newSpeed;\r\n    if (speed === \"fast\") newSpeed = [0.01, 0.02];\r\n    else if (speed === \"average\") newSpeed = [0.05, 0.1];\r\n    else if (speed === \"slow\") newSpeed = [0.25, 0.18];\r\n\r\n    changeSpeed(newSpeed);\r\n  };\r\n\r\n  resetBoard = () => {\r\n    let { resetBoard } = this.context;\r\n    this.setState({ visualizeClicked: false });\r\n    resetBoard();\r\n  };\r\n\r\n  render() {\r\n    let { algorithm } = this.context;\r\n    let algorithmDisplay, visualizeColor;\r\n    visualizeColor = \"#1abc9c\";\r\n    if (algorithm !== null) algorithmDisplay = `Visualize ${algorithm}!`;\r\n    else algorithmDisplay = \"Select an algorithm!\";\r\n\r\n    if (this.state.visualizeClicked) {\r\n      algorithmDisplay = \"Clear search!\";\r\n      visualizeColor = \"red\";\r\n    }\r\n\r\n    let lock;\r\n    if (this.props.lockBoard) lock = \"none\";\r\n    else lock = \"auto\";\r\n\r\n    let lockClearPath;\r\n    if (this.props.lockClearPath) lockClearPath = \"none\";\r\n    else lockClearPath = \"auto\";\r\n\r\n    return (\r\n      <nav className=\"navbar navbar-light\">\r\n        <a className=\"navbar-brand\" href=\"/\">\r\n          Search Algorithm Visulaizer\r\n        </a>\r\n        <div\r\n          id=\"visualize\"\r\n          className=\"btn-primary\"\r\n          onClick={() => this.handleClick(algorithm)}\r\n          style={{\r\n            backgroundColor: visualizeColor,\r\n            pointerEvents: lockClearPath\r\n          }}\r\n        >\r\n          {algorithmDisplay}\r\n        </div>\r\n        <div\r\n          id=\"reset\"\r\n          className=\"btn-secondary\"\r\n          onClick={() => this.resetBoard()}\r\n          style={{ pointerEvents: lock }}\r\n        >\r\n          Reset Board\r\n        </div>\r\n        <div className=\"dropdown\" style={{ pointerEvents: lock }}>\r\n          <button\r\n            className=\"dropdown-toggle\"\r\n            type=\"button\"\r\n            id=\"dropdownMenuButton\"\r\n            data-toggle=\"dropdown\"\r\n            aria-haspopup=\"true\"\r\n            aria-expanded=\"false\"\r\n          >\r\n            Mazes & Patterns\r\n          </button>\r\n          <div\r\n            className=\"dropdown-menu\"\r\n            aria-labelledby=\"dropdownMenuButton\"\r\n            style={{ pointerEvents: lock }}\r\n          >\r\n            <div\r\n              onClick={this.handleMaze}\r\n              id=\"random-weighted\"\r\n              className=\"dropdown-item\"\r\n            >\r\n              Random Weighted Maze\r\n            </div>\r\n            <div\r\n              onClick={this.handleMaze}\r\n              id=\"random-maze\"\r\n              className=\"dropdown-item\"\r\n            >\r\n              Random Maze\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div className=\"dropdown\" style={{ pointerEvents: lock }}>\r\n          <button\r\n            className=\"dropdown-toggle\"\r\n            type=\"button\"\r\n            id=\"dropdownMenuButton\"\r\n            data-toggle=\"dropdown\"\r\n            aria-haspopup=\"true\"\r\n            aria-expanded=\"false\"\r\n          >\r\n            Algorithms\r\n          </button>\r\n          <div\r\n            className=\"dropdown-menu\"\r\n            aria-labelledby=\"dropdownMenuButton\"\r\n            style={{ pointerEvents: lock }}\r\n          >\r\n            <div onClick={this.handleAlgo} id=\"BFS\" className=\"dropdown-item\">\r\n              Breadth First Search\r\n            </div>\r\n            <div onClick={this.handleAlgo} id=\"DFS\" className=\"dropdown-item\">\r\n              Depth First Search\r\n            </div>\r\n            <div\r\n              onClick={this.handleAlgo}\r\n              id=\"Greedy\"\r\n              className=\"dropdown-item\"\r\n            >\r\n              Greedy Best-First Search\r\n            </div>\r\n            <div\r\n              onClick={this.handleAlgo}\r\n              id=\"Dijkstra\"\r\n              className=\"dropdown-item\"\r\n            >\r\n              Dijkstra's Algorithm\r\n            </div>\r\n            <div onClick={this.handleAlgo} id=\"A*\" className=\"dropdown-item\">\r\n              A* Search\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div className=\"dropdown\" style={{ pointerEvents: lock }}>\r\n          <button\r\n            className=\"dropdown-toggle\"\r\n            type=\"button\"\r\n            id=\"dropdownMenuButton\"\r\n            data-toggle=\"dropdown\"\r\n            aria-haspopup=\"true\"\r\n            aria-expanded=\"false\"\r\n          >\r\n            Speed\r\n          </button>\r\n          <div\r\n            className=\"dropdown-menu\"\r\n            aria-labelledby=\"dropdownMenuButton\"\r\n            style={{ pointerEvents: lock }}\r\n          >\r\n            <div onClick={this.handleSpeed} id=\"fast\" className=\"dropdown-item\">\r\n              Fast\r\n            </div>\r\n            <div\r\n              onClick={this.handleSpeed}\r\n              id=\"average\"\r\n              className=\"dropdown-item\"\r\n            >\r\n              Average\r\n            </div>\r\n            <div onClick={this.handleSpeed} id=\"slow\" className=\"dropdown-item\">\r\n              Slow\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </nav>\r\n    );\r\n  }\r\n}\r\n\r\nNavbar.contextType = GridContext;\r\n\r\nexport default Navbar;\r\n","import React from \"react\";\r\n\r\nimport { GridContext } from \"../grid-context\";\r\n\r\nclass Cell extends React.Component {\r\n  handleClick = (id, cellState) => {\r\n    let { toggleMousePressed } = this.context;\r\n    toggleMousePressed(id);\r\n\r\n    if (cellState !== \"start\" && cellState !== \"end\") {\r\n      let { toggleCell } = this.context;\r\n      toggleCell(id, cellState);\r\n    }\r\n  };\r\n\r\n  handleMouseUp = id => {\r\n    let { toggleMousePressed, mousePressed } = this.context;\r\n    if (mousePressed) toggleMousePressed();\r\n  };\r\n\r\n  handleDrag = (id, cellState) => {\r\n    let { mousePressed, selectedCellVal, toggleCell } = this.context;\r\n    if (mousePressed) {\r\n      if (\r\n        selectedCellVal !== \"start\" &&\r\n        selectedCellVal !== \"end\" &&\r\n        (cellState !== \"start\") & (cellState !== \"end\")\r\n      ) {\r\n        toggleCell(id, cellState);\r\n      } else if (selectedCellVal === \"start\") {\r\n        toggleCell(id, \"start\");\r\n      } else if (selectedCellVal === \"end\") {\r\n        toggleCell(id, \"end\");\r\n      }\r\n    }\r\n  };\r\n\r\n  componentDidMount = () => {};\r\n\r\n  render() {\r\n    const { cellState, id, delay } = this.props;\r\n    let delayAnim;\r\n    if (typeof this.props.cellState === undefined) console.log(\"problem\");\r\n\r\n    if (\r\n      !this.props.cellState.startsWith(\"visited\") &&\r\n      !this.props.cellState.includes(\"path\")\r\n    ) {\r\n      delayAnim = \"\";\r\n    } else {\r\n      delayAnim = delay.toString() + \"s\";\r\n    }\r\n\r\n    return (\r\n      <td\r\n        className={cellState}\r\n        style={{ animationDelay: delayAnim }}\r\n        id={id}\r\n        onMouseDown={e => this.handleClick(id, cellState)}\r\n        onMouseUp={e => this.handleMouseUp(id)}\r\n        onMouseOver={e => this.handleDrag(id, cellState)}\r\n      ></td>\r\n    );\r\n  }\r\n}\r\n\r\nCell.contextType = GridContext;\r\n\r\nexport default Cell;\r\n","import React from \"react\";\r\nimport \"./Grid.scss\";\r\nimport Cell from \"./Cell\";\r\n\r\nimport { GridContext } from \"../grid-context\";\r\n\r\nclass Grid extends React.Component {\r\n  getVisitedIndex = (visited, indexes) => {\r\n    for (var i = 0; i < visited.length; i++) {\r\n      if (visited[i][0] === indexes[0] && visited[i][1] === indexes[1]) {\r\n        return i;\r\n      }\r\n    }\r\n    return 0;\r\n  };\r\n\r\n  createTable = () => {\r\n    let table = [];\r\n    let { grid } = this.context;\r\n    // Outer loop to create parent\r\n    for (let i = 0; i < grid.length; i++) {\r\n      let children = [];\r\n      //Inner loop to create children\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        let delay, index;\r\n        if (this.props.visited.length > 0) {\r\n          index = this.getVisitedIndex(this.props.visited, [i, j]);\r\n          delay = index * this.props.speed[0];\r\n        }\r\n        if (this.props.path.length > 0) {\r\n          index = this.getVisitedIndex(this.props.path, [i, j]);\r\n          delay = index * this.props.speed[1];\r\n        }\r\n        children.push(\r\n          <Cell\r\n            cellState={grid[i][j]}\r\n            id={i + \"-\" + j}\r\n            delay={delay}\r\n            key={i + \"-\" + j}\r\n          />\r\n        );\r\n      }\r\n      //Create the parent and add the children\r\n      table.push(<tr key={i}>{children}</tr>);\r\n    }\r\n    return table;\r\n  };\r\n\r\n  render() {\r\n    let table = this.createTable();\r\n    let lock;\r\n    if (this.props.lockBoard) lock = \"none\";\r\n    else lock = \"auto\";\r\n    return (\r\n      <table id=\"grid\" style={{ pointerEvents: lock }}>\r\n        <tbody>{table}</tbody>\r\n      </table>\r\n    );\r\n  }\r\n}\r\n\r\nGrid.contextType = GridContext;\r\n\r\nexport default Grid;\r\n","import React from \"react\";\r\nimport \"./AlgoInfo.scss\";\r\nimport { GridContext } from \"../grid-context\";\r\n\r\nclass AlgoInfo extends React.Component {\r\n  getAlgoProps = algo => {\r\n    let weighted, shortestPath;\r\n    if (algo === \"DFS\" || algo === \"BFS\") weighted = \"unweighted\";\r\n    else weighted = \"weighted\";\r\n    if (algo === \"BFS\" || algo === \"Dijkstra\" || algo === \"A*\")\r\n      shortestPath = \"does\";\r\n    else shortestPath = \"does not\";\r\n\r\n    return (\r\n      <div>\r\n        <span className=\"font-weight-bold\">{algo}</span> is{\" \"}\r\n        <span className=\"font-italic\">{weighted}</span> and {shortestPath}{\" \"}\r\n        garuntee the <span className=\"font-italic\">shortest path</span>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  getStats = algoStats => {\r\n    return (\r\n      <div className=\"d-flex align-items-center\">\r\n        <div className=\"d-flex block-container pr-3\">\r\n          <span className=\"block visited-block\"></span>\r\n          <p>\r\n            <span className=\"font-weight-bold\">{algoStats[0]}</span> nodes were{\" \"}\r\n            <span className=\"font-weight-bold\">visited</span>\r\n          </p>\r\n        </div>\r\n        <div className=\"d-flex block-container\">\r\n          <span className=\"block path-block\"></span>\r\n          <p>\r\n            <span className=\"font-weight-bold\">{algoStats[1]}</span> nodes in\r\n            the <span className=\"font-weight-bold\">path</span>\r\n          </p>\r\n        </div>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  render() {\r\n    let searchResults, algoProps;\r\n    if (this.props.algoStats.length)\r\n      searchResults = this.getStats(this.props.algoStats);\r\n    else searchResults = \"\";\r\n    if (this.props.algo) algoProps = this.getAlgoProps(this.props.algo);\r\n    else algoProps = \"\";\r\n\r\n    return (\r\n      <div>\r\n        <div className=\"legend container\">\r\n          <div className=\"d-flex pr-3\">\r\n            <span className=\"block start-block\"></span>Start Node\r\n          </div>\r\n          <div className=\"d-flex pr-3\">\r\n            <span className=\"block target-block\"></span>Target Node\r\n          </div>\r\n          <div className=\"d-flex pr-3\">\r\n            <span className=\"block weight-block\"></span>Weight Node\r\n          </div>\r\n          <div className=\"d-flex pr-3\">\r\n            <span className=\"block path-block\"></span>Path Node\r\n          </div>\r\n          <div className=\"d-flex pr-3\">\r\n            <span className=\"block visited-block\"></span>Visited Node\r\n          </div>\r\n          <div className=\"d-flex pr-3\">\r\n            <span className=\"block unvisited-block\"></span>Unvisited Node\r\n          </div>\r\n          <div className=\"d-flex pr-3\">\r\n            <span className=\"block wall-block\"></span>Wall Node\r\n          </div>\r\n        </div>\r\n        <div className=\"algo-display container\">\r\n          <div className=\"row h-100\">\r\n            <div className=\"col-12 col-md-6 my-auto\">{algoProps}</div>\r\n            <div className=\"col-12 col-md-6 my-auto node-info\">\r\n              {searchResults}\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nAlgoInfo.contextType = GridContext;\r\nexport default AlgoInfo;\r\n","export function initGrid() {\r\n  const dimensions = getGridDimensions();\r\n  const rows = dimensions[0];\r\n  const columns = dimensions[1];\r\n\r\n  let grid = Array(rows)\r\n    .fill(0)\r\n    .map(row => new Array(columns).fill(\"unvisited\"));\r\n\r\n  const startPoints = getStartPoints(rows, columns);\r\n  grid = updateGrid(grid, startPoints[1], startPoints[0], \"start\");\r\n\r\n  const endPoints = getTargetPoints(rows, columns);\r\n  grid = updateGrid(grid, endPoints[1], endPoints[0], \"end\");\r\n\r\n  function getGridDimensions() {\r\n    const columns = Math.floor(window.innerWidth / 25);\r\n    const rows = Math.floor(window.innerHeight / 25 - 2);\r\n    return [rows, columns];\r\n  }\r\n\r\n  function getStartPoints(rows, columns) {\r\n    const startX = Math.floor(columns / 4);\r\n    const startY = Math.floor(rows / 2);\r\n    return [startY, startX];\r\n  }\r\n\r\n  function getTargetPoints() {\r\n    const targetX = Math.floor(columns * 0.75);\r\n    const targetY = Math.floor(rows / 2);\r\n    return [targetY, targetX];\r\n  }\r\n\r\n  function updateGrid(grid, x, y, value) {\r\n    let newArray = grid.map((r, i) => {\r\n      if (i === y) {\r\n        return grid[y].map((c, j) => {\r\n          if (j === x) {\r\n            return value;\r\n          }\r\n          return c;\r\n        });\r\n      }\r\n      return r;\r\n    });\r\n\r\n    return newArray;\r\n  }\r\n\r\n  initGrid.updateGrid = updateGrid;\r\n  initGrid.getStartPoints = getStartPoints;\r\n  initGrid.getTargetPoints = getTargetPoints;\r\n  initGrid.getGridDimensions = getGridDimensions;\r\n\r\n  return grid;\r\n}\r\n","// Helper function to get grid coordinates of a point from the id in the table\r\nexport function getCoordinates(id) {\r\n  const indexes = id.split(\"-\").map(el => {\r\n    let n = parseInt(el);\r\n    return n;\r\n  });\r\n\r\n  return indexes;\r\n}\r\n","export function removeCells(grid, visited, path, weights) {\r\n  for (var i = 0; i < grid.length; i++) {\r\n    for (var j = 0; j < grid[0].length; j++) {\r\n      if (\r\n        grid[i][j].includes(\"visited\") &&\r\n        visited &&\r\n        !grid[i][j].includes(\"unvisited\")\r\n      )\r\n        grid[i][j] = grid[i][j].replace(\"visited\", \"unvisited\");\r\n\r\n      // remove path from cell if specified\r\n      if (grid[i][j].includes(\"path\") && path)\r\n        grid[i][j] = grid[i][j].replace(\"path\", \"unvisited\");\r\n\r\n      // remove weight from cell if specified\r\n      if (grid[i][j].includes(\"weight\") && weights)\r\n        grid[i][j] = grid[i][j].replace(\" weight\", \"\");\r\n    }\r\n  }\r\n  return grid;\r\n}\r\n","export function searchHelpers() {\r\n  // check visited array for a vertex\r\n  function hasVertex(array, array2D) {\r\n    if (array2D.length === 0) return false;\r\n\r\n    for (var i = 0; i < array2D.length; i++)\r\n      if (arraysMatch(array2D[i], array)) return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  // compare 2 arrays\r\n  function arraysMatch(arr1, arr2) {\r\n    if (arr1.length !== arr2.length) return false;\r\n\r\n    for (var i = 0; i < arr1.length; i++) {\r\n      if (arr1[i] !== arr2[i]) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // get all neighbor cells of given vertex\r\n  function getNeighbours(vertex, grid, rowCount, colCount) {\r\n    let neighbours = [];\r\n\r\n    if (inBounds([vertex[0] - 1, vertex[1]], rowCount, colCount))\r\n      if (grid[vertex[0] - 1][vertex[1]] !== \"wall\")\r\n        neighbours.push([vertex[0] - 1, vertex[1]]);\r\n\r\n    if (inBounds([vertex[0], vertex[1] + 1], rowCount, colCount))\r\n      if (grid[vertex[0]][vertex[1] + 1] !== \"wall\")\r\n        neighbours.push([vertex[0], vertex[1] + 1]);\r\n\r\n    if (inBounds([vertex[0] + 1, vertex[1]], rowCount, colCount))\r\n      if (grid[vertex[0] + 1][vertex[1]] !== \"wall\")\r\n        neighbours.push([vertex[0] + 1, vertex[1]]);\r\n\r\n    if (inBounds([vertex[0], vertex[1] - 1], rowCount, colCount))\r\n      if (grid[vertex[0]][vertex[1] - 1] !== \"wall\")\r\n        neighbours.push([vertex[0], vertex[1] - 1]);\r\n\r\n    return neighbours;\r\n  }\r\n\r\n  // helper funtion, check bounds of vertex based on grid size\r\n  function inBounds(vertex, rows, columns) {\r\n    if (\r\n      vertex[0] >= 0 &&\r\n      vertex[0] < rows &&\r\n      (vertex[1] >= 0 && vertex[1] < columns)\r\n    )\r\n      return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  function updateGrid(grid, visited, path) {\r\n    for (var i = 0; i < grid.length; i++) {\r\n      for (var j = 0; j < grid[0].length; j++) {\r\n        if (\r\n          searchHelpers.hasVertex([i, j], visited) &&\r\n          grid[i][j] !== \"start\" &&\r\n          grid[i][j] !== \"end\"\r\n        )\r\n          if (!path) {\r\n            if (grid[i][j] === \"unvisited\") grid[i][j] = \"visited\";\r\n            else if (grid[i][j] === \"unvisited weight\")\r\n              grid[i][j] = \"visited weight\";\r\n          } else grid[i][j] = \"path\";\r\n      }\r\n    }\r\n    return grid;\r\n  }\r\n\r\n  function getPath(path, end) {\r\n    let pathArray = [];\r\n    let currentCell = end;\r\n    while (currentCell !== null) {\r\n      pathArray.unshift(currentCell);\r\n      currentCell = path[currentCell];\r\n    }\r\n    return pathArray;\r\n  }\r\n\r\n  function manhattanDistance(position1, position2) {\r\n    const distanceX = Math.abs(position2[0] - position1[0]);\r\n    const distanceY = Math.abs(position2[1] - position1[1]);\r\n    return distanceX + distanceY;\r\n  }\r\n\r\n  searchHelpers.hasVertex = hasVertex;\r\n  searchHelpers.arraysMatch = arraysMatch;\r\n  searchHelpers.getNeighbours = getNeighbours;\r\n  searchHelpers.inBounds = inBounds;\r\n  searchHelpers.updateGrid = updateGrid;\r\n  searchHelpers.getPath = getPath;\r\n  searchHelpers.manhattanDistance = manhattanDistance;\r\n}\r\n","export default class PriorityQueue {\r\n  constructor() {\r\n    this.data = [];\r\n  }\r\n\r\n  push(value, priority = 0) {\r\n    return this.data.push({\r\n      value: value,\r\n      priority: priority\r\n    });\r\n  }\r\n\r\n  pop() {\r\n    let index = 0;\r\n    let min = Infinity;\r\n    for (let i = 0; i < this.data.length; i++) {\r\n      let priority = this.data[i].priority;\r\n      if (Math.min(min, priority) === priority) {\r\n        min = priority;\r\n        index = i;\r\n      }\r\n    }\r\n    return this.data.splice(index, 1)[0];\r\n  }\r\n\r\n  size() {\r\n    return this.data.length;\r\n  }\r\n}\r\n","import { randomWeights } from \"./mazes/randomWeights\";\r\nimport { randomMaze } from \"./mazes/randomMaze\";\r\n\r\nexport function mazeHandler(maze, grid) {\r\n  let newMaze;\r\n  if (maze === \"random-weighted\")\r\n    newMaze = randomWeights(grid);\r\n  else if (maze === \"random-maze\")\r\n    newMaze = randomMaze(grid);\r\n\r\n  return newMaze;\r\n}\r\n","export function randomWeights(grid, start, end) {\r\n  // for total weights\r\n  // pick a coordinate in the grid\r\n  // if the coordinate is not taken, fill it, if it is, fill another\r\n  // coordinates filled with random weight from 1-10\r\n  for (var i = 0; i < grid.length; i++) {\r\n    for (var j = 0; j < grid[0].length; j++) {\r\n      // first remove all walls and current weights\r\n      if (grid[i][j] === \"wall\") grid[i][j] = \"unvisited\";\r\n      if (grid[i][j].includes(\"weight\")) grid[i][j] = \"unvisited\";\r\n      // populate 40% of board with weights\r\n      if (probability(0.4) && grid[i][j] !== \"start\" && grid[i][j] !== \"end\") {\r\n        grid[i][j] = `${grid[i][j]} weight`;\r\n      }\r\n    }\r\n  }\r\n\r\n  function probability(n) {\r\n    return !!n && Math.random() <= n;\r\n  }\r\n\r\n  return grid;\r\n}\r\n","export function randomMaze(grid, start, end) {\r\n  const width = grid[0].length;\r\n  const height = grid.length;\r\n\r\n  for (var i = 0; i < grid.length; i++) {\r\n    for (var j = 0; j < grid[0].length; j++) {\r\n      if (grid[i][j] !== \"start\" && grid[i][j] !== \"end\") grid[i][j] = \"wall\";\r\n    }\r\n  }\r\n\r\n  randomMazeUtil(grid, 0, 0, width, height, chooseOrientation(width, height));\r\n\r\n  function randomMazeUtil(grid, x, y, width, height, orientation) {\r\n    if (width < 2 || height < 2) return grid;\r\n\r\n    // horizontal or veritcal ?\r\n    let horizontal = orientation;\r\n\r\n    // where will the wall be drawn from?\r\n    let wx = x + (horizontal ? 0 : Math.floor(Math.random() * (width - 1)));\r\n    let wy = y + (horizontal ? Math.floor(Math.random() * (height - 1)) : 0);\r\n\r\n    // where will the passage through the wall exist?\r\n    let px = wx + (horizontal ? Math.floor(Math.random() * width) : 0);\r\n    let py = wy + (horizontal ? 0 : Math.floor(Math.random() * height));\r\n\r\n    // what direction will the wall be drawn?\r\n    let dx = horizontal ? 1 : 0;\r\n    let dy = horizontal ? 0 : 1;\r\n\r\n    // how long will the wall be?\r\n    let length = horizontal ? width : height;\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      if (wx !== px || wy !== py) {\r\n        if (grid[wy][wx] !== \"start\" && grid[wy][wx] !== \"end\")\r\n          grid[wy][wx] = \"unvisited\";\r\n      }\r\n      wx += dx;\r\n      wy += dy;\r\n    }\r\n\r\n    let nx = x;\r\n    let ny = y;\r\n    let w = horizontal ? width : wx - x + 1;\r\n    let h = horizontal ? wy - y + 1 : height;\r\n    randomMazeUtil(grid, nx, ny, w, h, chooseOrientation(w, h));\r\n\r\n    nx = horizontal ? x : wx + 1;\r\n    ny = horizontal ? wy + 1 : y;\r\n    w = horizontal ? width : x + width - wx - 1;\r\n    h = horizontal ? y + height - wy - 1 : height;\r\n    randomMazeUtil(grid, nx, ny, w, h, chooseOrientation(w, h));\r\n  }\r\n\r\n  // helper function, choose orientation of division\r\n  function chooseOrientation(width, height) {\r\n    if (width < height) return 1;\r\n    else if (height < width) return 0;\r\n    else return Math.random(2) === 0 ? 1 : 0;\r\n  }\r\n\r\n  return grid;\r\n}\r\n","import React from \"react\";\r\nimport Navbar from \"./Navbar.jsx\";\r\nimport Grid from \"./Grid.jsx\";\r\nimport AlgoInfo from \"./AlgoInfo.jsx\";\r\n\r\nimport { GridContext, myState } from \"../grid-context\";\r\n\r\n// helper utilities\r\nimport { initGrid } from \"../utilities/initGrid\";\r\nimport { getCoordinates } from \"../utilities/getCoordinates\";\r\nimport { movePoint } from \"../utilities/movePoint\";\r\nimport { removeCells } from \"../utilities/removeCells\";\r\n\r\n// algorithms\r\nimport { DFS } from \"../utilities/searchAlgorithms/DFS\";\r\nimport { BFS } from \"../utilities/searchAlgorithms/BFS\";\r\nimport { Dijkstra } from \"../utilities/searchAlgorithms/Dijkstra\";\r\nimport { AStar } from \"../utilities/searchAlgorithms/AStar\";\r\nimport { Greedy } from \"../utilities/searchAlgorithms/Greedy\";\r\n\r\n// boards and mazes creation\r\nimport { mazeHandler } from \"../utilities/mazeHandler\";\r\n\r\nclass App extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.setAlgorithm = algorithm => {\r\n      this.setState({ algorithm: algorithm });\r\n    };\r\n    this.createMaze = maze => {\r\n      this.setState({ grid: mazeHandler(maze, this.state.grid) });\r\n    };\r\n    // add options to preserve walls, start & end points and weights\r\n    this.resetBoard = resetSearch => {\r\n      if (!resetSearch) {\r\n        this.setState({ grid: initGrid(), path: [], visited: [] });\r\n        this.setState({\r\n          startPoint: this.getStart(),\r\n          target: this.getTarget(),\r\n          algoStats: []\r\n        });\r\n      } else {\r\n        this.setState({\r\n          grid: removeCells(this.state.grid, true, true, false),\r\n          path: [],\r\n          visited: [],\r\n          lockBoard: false,\r\n          algoStats: []\r\n        });\r\n      }\r\n    };\r\n    this.toggleMousePressed = id => {\r\n      // mouse is pressed, toggle off and empty selected cell point\r\n      if (this.state.mousePressed) {\r\n        this.setState({ mousePressed: false });\r\n        this.setState({ selectedCellVal: null });\r\n        // mouse isn't pressed, toggle on and set selected cell\r\n      } else {\r\n        this.setState({ mousePressed: true });\r\n        const indexes = getCoordinates(id);\r\n        this.setState({\r\n          selectedCellVal: this.state.grid[indexes[0]][indexes[1]]\r\n        });\r\n      }\r\n    };\r\n    this.toggleCell = (id, cellValue) => {\r\n      const indexes = getCoordinates(id);\r\n      const curVal = this.state.grid[indexes[0]][indexes[1]];\r\n\r\n      if (\r\n        this.state.selectedCellVal === \"start\" ||\r\n        this.state.selectedCellVal === \"end\"\r\n      ) {\r\n        let newCell, points;\r\n        if (\r\n          this.state.selectedCellVal === \"start\" &&\r\n          this.state.grid[indexes[0]][indexes[1]] !== \"end\"\r\n        ) {\r\n          newCell = \"start\";\r\n          points = [this.state.startPoint[0], this.state.startPoint[1]];\r\n          this.setState({ startPoint: indexes });\r\n        } else if (\r\n          this.state.selectedCellVal === \"end\" &&\r\n          this.state.grid[indexes[0]][indexes[1]] !== \"start\"\r\n        ) {\r\n          newCell = \"end\";\r\n          points = [this.state.target[0], this.state.target[1]];\r\n          this.setState({ target: indexes });\r\n        }\r\n\r\n        if (points !== undefined) {\r\n          const newGrid = movePoint(\r\n            this.state.grid,\r\n            points[0],\r\n            points[1],\r\n            indexes[0],\r\n            indexes[1],\r\n            newCell\r\n          );\r\n\r\n          this.setState(\r\n            {\r\n              grid: newGrid\r\n            },\r\n            () => {\r\n              if (curVal === \"wall\" || curVal.includes(\"weight\"))\r\n                this.setState({\r\n                  lastCell: { cell: curVal, points: [indexes[0], indexes[1]] }\r\n                });\r\n              if (\r\n                this.state.lastCell.cell === \"wall\" ||\r\n                this.state.lastCell.cell.includes(\"weight\")\r\n              ) {\r\n                this.setState({\r\n                  grid: initGrid.updateGrid(\r\n                    this.state.grid,\r\n                    this.state.lastCell.points[1],\r\n                    this.state.lastCell.points[0],\r\n                    this.state.lastCell.cell\r\n                  )\r\n                });\r\n              }\r\n            }\r\n          );\r\n        }\r\n      } else {\r\n        let newCellValue;\r\n        if (cellValue === \"wall\") newCellValue = \"unvisited\";\r\n        else if (\r\n          cellValue === \"unvisited\" ||\r\n          cellValue === \"visited\" ||\r\n          cellValue === \"path\" ||\r\n          cellValue === \"weight\" ||\r\n          cellValue === \"visited weight\" ||\r\n          cellValue === \"unvisited weight\"\r\n        )\r\n          newCellValue = \"wall\";\r\n        this.setState({\r\n          grid: initGrid.updateGrid(\r\n            this.state.grid,\r\n            indexes[1],\r\n            indexes[0],\r\n            newCellValue\r\n          )\r\n        });\r\n      }\r\n    };\r\n    this.initGrid = () => {\r\n      return initGrid();\r\n    };\r\n    this.getStart = () => {\r\n      const dimensions = initGrid.getGridDimensions();\r\n      const start = initGrid.getStartPoints(dimensions[0], dimensions[1]);\r\n      return start;\r\n    };\r\n    this.getTarget = () => {\r\n      const dimensions = initGrid.getGridDimensions();\r\n      const target = initGrid.getTargetPoints(dimensions[0], dimensions[1]);\r\n      return target;\r\n    };\r\n\r\n    this.visualize = algorithm => {\r\n      this.setState({\r\n        willVisualize: true\r\n      });\r\n    };\r\n\r\n    this.changeSpeed = speed => {\r\n      this.setState({ speed: speed });\r\n    };\r\n\r\n    this.state = {\r\n      grid: this.initGrid(),\r\n      startPoint: this.getStart(),\r\n      target: this.getTarget(),\r\n      selectedCells: myState.grid,\r\n      algorithm: myState.algorithm,\r\n      mousePressed: myState.mousePressed,\r\n      selectedCellVal: myState.selectedCellVal,\r\n      visited: myState.visited,\r\n      path: myState.path,\r\n      lastCell: { cell: \"\", points: [] },\r\n      resetBoard: this.resetBoard,\r\n      setAlgorithm: this.setAlgorithm,\r\n      createMaze: this.createMaze,\r\n      toggleMousePressed: this.toggleMousePressed,\r\n      visualize: this.visualize,\r\n      willVisualize: false,\r\n      toggleCell: this.toggleCell,\r\n      drag: this.drag,\r\n      speed: myState.speed,\r\n      changeSpeed: this.changeSpeed,\r\n      lockBoard: myState.lockBoard,\r\n      lockClearPath: myState.lockClearPath,\r\n      algoStats: []\r\n    };\r\n  }\r\n\r\n  showPath = () => {\r\n    let results;\r\n    let algorithm = this.state.algorithm;\r\n\r\n    // use selected search\r\n    switch (algorithm) {\r\n      case \"DFS\":\r\n        results = DFS(\r\n          this.state.grid,\r\n          this.state.startPoint,\r\n          this.state.target\r\n        );\r\n\r\n        break;\r\n      case \"BFS\":\r\n        results = BFS(\r\n          this.state.grid,\r\n          this.state.startPoint,\r\n          this.state.target\r\n        );\r\n        break;\r\n      case \"Dijkstra\":\r\n        results = Dijkstra(\r\n          this.state.grid,\r\n          this.state.startPoint,\r\n          this.state.target\r\n        );\r\n        break;\r\n      case \"A*\":\r\n        results = AStar(\r\n          this.state.grid,\r\n          this.state.startPoint,\r\n          this.state.target\r\n        );\r\n        break;\r\n      case \"Greedy\":\r\n        results = Greedy(\r\n          this.state.grid,\r\n          this.state.startPoint,\r\n          this.state.target\r\n        );\r\n        break;\r\n      default:\r\n        this.setState({\r\n          willVisualize: false\r\n        });\r\n        return;\r\n    }\r\n\r\n    // animate grid with results of search\r\n    setTimeout(() => {\r\n      this.setState({\r\n        visited: results.visited,\r\n        grid: results.newGrid,\r\n        lockBoard: true,\r\n        lockClearPath: true\r\n      });\r\n    }, 1);\r\n\r\n    const showPath = results.visited.length * this.state.speed[0] * 1000 + 900;\r\n\r\n    setTimeout(() => {\r\n      this.setState({\r\n        grid: results.gridWithPath,\r\n        path: results.pathArray,\r\n        willVisualize: false\r\n      });\r\n    }, showPath);\r\n\r\n    const pathShown =\r\n      showPath + results.pathArray.length * this.state.speed[1] * 1000;\r\n\r\n    setTimeout(() => {\r\n      this.setState({\r\n        lockClearPath: false,\r\n        algoStats: [results.visited.length, results.pathArray.length]\r\n      });\r\n    }, pathShown + 100);\r\n  };\r\n\r\n  componentDidUpdate(previousProps, previousState) {\r\n    if (\r\n      this.state.willVisualize &&\r\n      previousState.willVisualize !== this.state.willVisualize\r\n    ) {\r\n      this.showPath();\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <GridContext.Provider value={this.state}>\r\n          <Navbar\r\n            lockBoard={this.state.lockBoard}\r\n            lockClearPath={this.state.lockClearPath}\r\n          />\r\n          <AlgoInfo\r\n            algoStats={this.state.algoStats}\r\n            algo={this.state.algorithm}\r\n          ></AlgoInfo>\r\n          <Grid\r\n            visited={this.state.visited}\r\n            path={this.state.path}\r\n            speed={this.state.speed}\r\n            lockBoard={this.state.lockBoard}\r\n          />\r\n        </GridContext.Provider>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","import { searchHelpers } from \"../searchHelpers\";\r\n\r\nexport function DFS(grid, start, end) {\r\n  // initialize helper functions\r\n  searchHelpers();\r\n\r\n  const { visited, pathArray } = dfs(grid, start, end);\r\n  let newGrid = searchHelpers.updateGrid(grid, visited, false);\r\n  let gridWithPath = newGrid.map(function(arr) {\r\n    return arr.slice();\r\n  });\r\n\r\n  if (pathArray !== null)\r\n    gridWithPath = searchHelpers.updateGrid(gridWithPath, pathArray, true);\r\n\r\n  function dfs(grid, vertex, end) {\r\n    let stack = [],\r\n      visited = [],\r\n      path = {},\r\n      pathArray = [];\r\n    stack.push(vertex);\r\n\r\n    while (stack.length > 0) {\r\n      let cur = stack.pop();\r\n      visited.push(cur);\r\n      const neighbors = searchHelpers.getNeighbours(\r\n        cur,\r\n        grid,\r\n        grid.length,\r\n        grid[0].length\r\n      );\r\n      if (neighbors) {\r\n        for (var neighbour of neighbors) {\r\n          if (!searchHelpers.hasVertex(neighbour, visited)) {\r\n            visited.push(neighbour);\r\n            stack.push(neighbour);\r\n            path[neighbour] = cur;\r\n            // path found, return\r\n            if (searchHelpers.arraysMatch(neighbour, end)) {\r\n              // get the path by reversing the stack\r\n              path[end] = cur;\r\n              let tempCur = end;\r\n              while (!searchHelpers.arraysMatch(tempCur, vertex)) {\r\n                pathArray.unshift(tempCur);\r\n                tempCur = path[tempCur];\r\n              }\r\n              return { visited, pathArray };\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return { visited, pathArray };\r\n  }\r\n\r\n  return { newGrid, gridWithPath, visited, pathArray };\r\n}\r\n","import { searchHelpers } from '../searchHelpers';\r\n\r\nexport function BFS(grid, start, end) {\r\n\r\n    // initialize helper functions\r\n    searchHelpers();\r\n\r\n    const { visited, pathArray } = bfs(grid, start, end);\r\n    let newGrid = searchHelpers.updateGrid(grid, visited, false);\r\n    let gridWithPath = newGrid.map(function (arr) {\r\n        return arr.slice();\r\n    });\r\n\r\n    if (pathArray !== null)\r\n        gridWithPath = searchHelpers.updateGrid(gridWithPath, pathArray, true);\r\n\r\n    function bfs(grid, vertex, end) {\r\n        let stack = [],\r\n            visited = [],\r\n            path = {},\r\n            pathArray = [];\r\n\r\n        stack.unshift(vertex);\r\n        visited.push(vertex);\r\n\r\n        while (stack.length > 0) {\r\n            let cur = stack.pop();\r\n\r\n            // target found\r\n            if (searchHelpers.arraysMatch(cur, end)) {\r\n                path[vertex] = cur;\r\n                let tempCur = end;\r\n                while (!searchHelpers.arraysMatch(tempCur, vertex)) {\r\n                    pathArray.unshift(tempCur);\r\n                    tempCur = path[tempCur];\r\n                }\r\n                return { visited, pathArray };\r\n            }\r\n\r\n            const neighbors = searchHelpers.getNeighbours(cur, grid, grid.length, grid[0].length);\r\n            if (neighbors) {\r\n                for (var neighbor of neighbors) {\r\n                    if (!searchHelpers.hasVertex(neighbor, visited)) {\r\n                        visited.push(neighbor);\r\n                        path[neighbor] = cur;\r\n                        stack.unshift(neighbor);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return { visited, pathArray };\r\n    }\r\n\r\n    return { newGrid, gridWithPath, visited, pathArray };\r\n}\r\n","import { searchHelpers } from \"../searchHelpers\";\r\nimport PriorityQueue from \"../PriorityQueue\";\r\n\r\nexport function Dijkstra(grid, start, end) {\r\n  // initialize helper functions\r\n  searchHelpers();\r\n\r\n  const { visited, pathArray } = dijkstra(grid, start, end);\r\n\r\n  let newGrid = searchHelpers.updateGrid(grid, visited, false);\r\n  let gridWithPath = newGrid.map(function(arr) {\r\n    return arr.slice();\r\n  });\r\n\r\n  if (pathArray !== null)\r\n    gridWithPath = searchHelpers.updateGrid(gridWithPath, pathArray, true);\r\n\r\n  function dijkstra(grid, start, end) {\r\n    let visited = [];\r\n    let distances = {},\r\n      path = {};\r\n    let pq = new PriorityQueue();\r\n\r\n    // set dist of start cell to 0\r\n    distances[start] = 0;\r\n    pq.push(start, 0);\r\n\r\n    // initialize all viable cells to infinite (NOT WALLS)\r\n    for (var i = 0; i < grid.length; i++) {\r\n      for (var j = 0; j < grid[0].length; j++) {\r\n        if (!grid[i][j].includes(\"wall\")) {\r\n          let thisCell = [i, j];\r\n          if (!grid[i][j].includes(\"start\")) distances[thisCell] = Infinity;\r\n          path[thisCell] = null;\r\n        }\r\n      }\r\n    }\r\n\r\n    while (pq.size() > 0) {\r\n      // dequeue\r\n      let minCell = pq.pop();\r\n      let currentNode = minCell.value;\r\n\r\n      // mark visited for animations\r\n      if (\r\n        !searchHelpers.arraysMatch(minCell.value, start) &&\r\n        !searchHelpers.arraysMatch(minCell.value, end)\r\n      )\r\n        visited.push(minCell.value);\r\n      const neighbors = searchHelpers.getNeighbours(\r\n        currentNode,\r\n        grid,\r\n        grid.length,\r\n        grid[0].length\r\n      );\r\n      // check neighbours\r\n      if (neighbors) {\r\n        for (var neighbor of neighbors) {\r\n          let neighborWeight;\r\n          if (grid[neighbor[0]][neighbor[1]].includes(\"weight\"))\r\n            neighborWeight = 10;\r\n          else neighborWeight = 1;\r\n\r\n          let alternative = distances[currentNode] + neighborWeight;\r\n          if (alternative < distances[neighbor]) {\r\n            distances[neighbor] = alternative;\r\n            path[neighbor] = currentNode;\r\n            pq.push(neighbor, distances[neighbor]);\r\n          }\r\n          // if target found, cut search and return\r\n          if (searchHelpers.arraysMatch(neighbor, end)) {\r\n            const pathArray = searchHelpers.getPath(path, end);\r\n            return { visited, pathArray };\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return { visited, pathArray };\r\n  }\r\n\r\n  return { newGrid, gridWithPath, visited, pathArray };\r\n}\r\n","import { searchHelpers } from \"../searchHelpers\";\r\nimport PriorityQueue from \"../PriorityQueue\";\r\n\r\nexport function AStar(grid, start, end) {\r\n  // initialize helper functions\r\n  searchHelpers();\r\n\r\n  const { visited, pathArray } = AStar(grid, start, end);\r\n\r\n  let newGrid = searchHelpers.updateGrid(grid, visited, false);\r\n  let gridWithPath = newGrid.map(function(arr) {\r\n    return arr.slice();\r\n  });\r\n\r\n  if (pathArray !== null)\r\n    gridWithPath = searchHelpers.updateGrid(gridWithPath, pathArray, true);\r\n\r\n  function AStar(grid, start, end) {\r\n    let visited = [],\r\n      pathArray = [];\r\n\r\n    let path = {},\r\n      gScore = {},\r\n      fScore = {};\r\n\r\n    // initial discovered node is the start only\r\n    let open = new PriorityQueue();\r\n    gScore[start] = 0;\r\n    fScore[start] = searchHelpers.manhattanDistance(start, end);\r\n    open.push(start, fScore[start]);\r\n\r\n    // initialize all viable cells to infinite (NOT WALLS)\r\n    for (var i = 0; i < grid.length; i++) {\r\n      for (var j = 0; j < grid[0].length; j++) {\r\n        if (!grid[i][j].includes(\"wall\")) {\r\n          let thisCell = [i, j];\r\n          if (!grid[i][j].includes(\"start\")) {\r\n            gScore[thisCell] = Infinity;\r\n            fScore[thisCell] = Infinity;\r\n          }\r\n          path[thisCell] = null;\r\n        }\r\n      }\r\n    }\r\n\r\n    while (open.size() > 0) {\r\n      // dequeue\r\n      let minCell = open.pop();\r\n      let currentNode = minCell.value;\r\n\r\n      // if target found, cut search and return\r\n      if (searchHelpers.arraysMatch(currentNode, end)) {\r\n        const pathArray = searchHelpers.getPath(path, end);\r\n        return { visited, pathArray };\r\n      }\r\n\r\n      // track visited nodes for animation\r\n      if (!visited.includes(currentNode)) {\r\n        visited.push(currentNode);\r\n      }\r\n\r\n      // normal case, traverse neighbours\r\n      const neighbors = searchHelpers.getNeighbours(\r\n        currentNode,\r\n        grid,\r\n        grid.length,\r\n        grid[0].length\r\n      );\r\n\r\n      for (var neighbor of neighbors) {\r\n        let potentialScore;\r\n        // score based on weighted cell or not\r\n        if (grid[neighbor[0]][neighbor[1]].includes(\"weight\"))\r\n          potentialScore = gScore[currentNode] + 10;\r\n        else potentialScore = gScore[currentNode] + 1;\r\n        // new best path found, record it\r\n        if (potentialScore < gScore[neighbor]) {\r\n          path[neighbor] = currentNode;\r\n          gScore[neighbor] = potentialScore;\r\n          fScore[neighbor] =\r\n            potentialScore + searchHelpers.manhattanDistance(neighbor, end);\r\n          if (!open[neighbor]) {\r\n            open.push(neighbor, fScore[neighbor]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return { visited, pathArray };\r\n  }\r\n\r\n  return { newGrid, gridWithPath, visited, pathArray };\r\n}\r\n","import { searchHelpers } from \"../searchHelpers\";\r\nimport PriorityQueue from \"../PriorityQueue\";\r\n\r\nexport function Greedy(grid, start, end) {\r\n  // initialize helper functions\r\n  searchHelpers();\r\n\r\n  const { visited, pathArray } = greedy(grid, start, end);\r\n  let newGrid = searchHelpers.updateGrid(grid, visited, false);\r\n  let gridWithPath = newGrid.map(function(arr) {\r\n    return arr.slice();\r\n  });\r\n\r\n  if (pathArray !== null)\r\n    gridWithPath = searchHelpers.updateGrid(gridWithPath, pathArray, true);\r\n\r\n  function greedy(grid, start, end) {\r\n    let visited = [],\r\n      path = {},\r\n      pathArray = [];\r\n\r\n    let pq = new PriorityQueue();\r\n    pq.push(start, 0);\r\n    visited.push(start);\r\n\r\n    while (pq.size() > 0) {\r\n      let minCell = pq.pop();\r\n      let cur = minCell.value;\r\n      // let currentWeight = minCell.priority;\r\n\r\n      // target found\r\n      if (searchHelpers.arraysMatch(cur, end)) {\r\n        path[start] = cur;\r\n        let tempCur = end;\r\n        while (!searchHelpers.arraysMatch(tempCur, start)) {\r\n          pathArray.unshift(tempCur);\r\n          tempCur = path[tempCur];\r\n        }\r\n        return { visited, pathArray };\r\n      }\r\n\r\n      // track visited nodes for animation\r\n      if (!visited.includes(cur)) {\r\n        visited.push(cur);\r\n      }\r\n\r\n      const neighbors = searchHelpers.getNeighbours(\r\n        cur,\r\n        grid,\r\n        grid.length,\r\n        grid[0].length\r\n      );\r\n\r\n      if (neighbors) {\r\n        for (var neighbor of neighbors) {\r\n          if (!searchHelpers.hasVertex(neighbor, visited)) {\r\n            // visited.push(neighbor);\r\n            path[neighbor] = cur;\r\n            let cost;\r\n            // score based on weighted cell or not\r\n            if (grid[neighbor[0]][neighbor[1]].includes(\"weight\"))\r\n              cost = searchHelpers.manhattanDistance(neighbor, end) + 10;\r\n            else cost = searchHelpers.manhattanDistance(neighbor, end) + 1;\r\n\r\n            pq.push(neighbor, cost);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return { visited, pathArray };\r\n  }\r\n\r\n  return { newGrid, gridWithPath, visited, pathArray };\r\n}\r\n","// Helper function to move one cell value to another point on the grid\r\nexport function movePoint(grid, currentX, currentY, newX, newY, value) {\r\n  grid[currentX][currentY] = \"unvisited\";\r\n  grid[newX][newY] = value;\r\n  return grid;\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './components/App.jsx';\r\n\r\nReactDOM.render(<App />,\r\n    document.querySelector('#root')\r\n);"],"sourceRoot":""}